# JVM随笔
##### 
##### **JVM** = java virtual machine  
##### ### 一共有五个部分
1. 程序计数器
2. java虚拟机栈
3. 方法栈
4. 堆
5. 方法区

## 程序计数器
程序计数器是一块很小的内存空间,也就是当前线程的增在执行的字节码行号指示器[记录着当前线程正在执行的哪一条字节码指令的地址]
ps: 如果是执行本地方法,那么程序计数器就是空的

### 程序计数器的作用:
1. 字节码解释器通过改变程序计数器来读取指令,从而实现对代码流的控制.
2. 多线程的时候,程序计数器记录当前线程执行的位置,当线程切回来的时候能知道线程之前运行到哪里了.

### 程序计数器的特点
1. 是一小块存储空间
2. 线程私有的
3. 是唯一一个不会outofmemoryerror的区域
4. 生命周期围绕线程

## java虚拟机栈

java虚拟机栈是描述java方法运行过程中的内存模型

java虚拟机栈会为每一个即将运行的java程序创建一块叫做""栈帧"的区域,这个区域用于存储该方法在运行过程中所需要的一些信息.
1. 局部变量表  存放当基本数据类型变量 引用类型的变量 returnAddress类型的变量
2. 操作数栈
3. 动态链接
4. 方法出口信息
当一个方法即将被运行的时候,java虚拟机栈首先会在java虚拟机栈中创建一块 栈帧 .栈帧中包含了局部变量表,操作数栈,动态链接和方法出口等信息.当方法在运行的过程中需要创建局部变量的时候就将局部变量的值存入栈帧的局部变量表中.
当着个方法执行吃那个完毕之后,这个方法所对应的栈帧建辉出栈,然后释放内存空间.
ps: 所谓的java栈和对 栈中放局部变量 堆中放对象 这种描述是有问题的. 
堆的理解尚可接受 但是栈是代表了java虚拟机栈中的局部变量表部分,真正的Java虚拟机栈是由一个个栈帧组成的.

### java虚拟机栈的特点

1. 局部变量表的创建实在方法被执行的时候,随着栈帧的创建而创建.而且局部变量表的大小在编译的时期就已经确定了,在创建的时候只要分配之前规定的大小就好.在方法运行的过程中,局部变量表是不会发生大小改变的
2. java虚拟机一般会有两种异常 StackOverflowError 和 OutOfMemoryError
1. 1.     StackOverflowError
  如果java虚拟机栈的内存大小不可以动态扩展,那么当线程请求栈的深度超过了java虚拟机栈的最大深度的时候就会抛出这个异常
1. 1.     OutOfMemoryError
  如果java虚拟机栈可以扩展,当线程请求的栈的内存用完了,无法继续扩展了,就会抛出这个异常
3. 这两个异常的区别
StackOverflowError表示当前线程申请的栈超过了之前设定好的最大深度,但是内存的空间还是可能有的.
OutOfMemoryError是当线程申请栈的时候栈已经满了,内存也没有了.

## 本地方法栈

### 什么是本地方法栈 
