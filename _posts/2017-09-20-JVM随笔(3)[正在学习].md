# 理解jvm 3 垃圾收集策略详解

java 虚拟机的内存模型分为五个部分，分别是：程序计数器，java虚拟机栈，本地方法栈，堆和方法区

这个五个区域都是存储空间，为了避免java虚拟机在运行期间内存满，就必须要进行垃圾回收。

这就是我们说的GC收集器

程序计数器，Java虚拟机栈，本地方法栈都是线程私有的，也就是每一个线程都拥有这三块区域，而且随着线程的创建而创建，随着线程的结束而结束。因为Java虚拟机栈和本地方法栈都是随着方法的开始而入栈，随着方法的结束而出栈，而且栈帧中的本地变量都是在类被加载的时候就确定的。这三个区域的垃圾回收工作具有确定性，垃圾回收器可以知道何时去清扫这三块区域中的那些数据。

但是重点是堆中的内存清理工作。
堆和方法区所有线程共享，而且都在JVM启动的时候就创建，在JVM停止的时候销毁。虽然每个对象的内存大小在加载该对象的时候就确定了，但是究竟创造多少个对象只有在程序运行期间才能确定
方法区中存放类信息 静态成员变量 常量。 累的加载实在程序的运行过程中，当需要那个类才会加载这个类，所以JVM到底要加载多少个类也是要在运行的时候才能确定。

由于上述的不确定性。才导致GC算法的复杂性。

## 堆内存的回收

### 如何判断哪些对象需要回收？

在对象进行回收之前，要判断哪些是无用的对象，如果一个对象没有被任何对象引用就是无效对象：
1. 引用计数法 每个对象都有一个计数器，当这个对象被一个变量或者另一个对象引用一次，该计数器加一；如果引用失效就减一，当计数器为零的时候就销毁对象
2. 可达性分析法 所有和GC Roots直接或间接关联的对象都是有效对象，无关联的都是无效对象。
GC Roots是指： 1. Java虚拟机栈引用的对象（栈帧中局部变量表中引用类型的变量所引用的变量）2. 方法区中静态属性引用的对象 3. 方法区中常量所引用的对象 4. 本地方法栈所引用的对象【ps： GC Roots 不包括堆中对象所引用的对象，防止循环引用出现】

对比：
   引用计数虽然简单，但是无法解决循环引用的问题，所以主流使用可达性分析法。

## 回收无效对象的过程

当JVM筛选出失效对象之后，并不是立即清除，而是再给对象一次重生的机会：

1. 判断这个对象是否覆盖了finalize 方法  
   1. 如果已经覆盖了这个方法，并且这个对象的finalize方法还没有执行过，那么就会将finalize 方法扔到F-Quene队列中
   2. 如果没有覆盖方法，直接释放内存
2. 执行F-Quene队列中的finalize方法 虚拟机会一较低的优先级执行这些finalize方法们，也不会确保所有的finalize方法否会执行到结束。如果finalize方法中出现耗时的操作，虚拟机应该立即停止执行，释放该对象的内存。
3. 对象的重生或死亡  如果过在执行finalize方法的时候，将this赋给了某一个引用，那么这个对象就重生了。反之就会被回收清除。
  

