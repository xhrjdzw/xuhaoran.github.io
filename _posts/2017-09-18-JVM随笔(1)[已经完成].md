# JVM随笔
##### 
##### **JVM** = java virtual machine  
##### ### 一共有五个部分
1. 程序计数器
2. java虚拟机栈
3. 方法栈
4. 堆
5. 方法区

## 程序计数器
程序计数器是一块很小的内存空间,也就是当前线程的增在执行的字节码行号指示器[记录着当前线程正在执行的哪一条字节码指令的地址]
ps: 如果是执行本地方法,那么程序计数器就是空的

### 程序计数器的作用:
1. 字节码解释器通过改变程序计数器来读取指令,从而实现对代码流的控制.
2. 多线程的时候,程序计数器记录当前线程执行的位置,当线程切回来的时候能知道线程之前运行到哪里了.

### 程序计数器的特点
1. 是一小块存储空间
2. 线程私有的
3. 是唯一一个不会outofmemoryerror的区域
4. 生命周期围绕线程

## java虚拟机栈

java虚拟机栈是描述java方法运行过程中的内存模型

java虚拟机栈会为每一个即将运行的java程序创建一块叫做""栈帧"的区域,这个区域用于存储该方法在运行过程中所需要的一些信息.
1. 局部变量表  存放当基本数据类型变量 引用类型的变量 returnAddress类型的变量
2. 操作数栈
3. 动态链接
4. 方法出口信息
当一个方法即将被运行的时候,java虚拟机栈首先会在java虚拟机栈中创建一块 栈帧 .栈帧中包含了局部变量表,操作数栈,动态链接和方法出口等信息.当方法在运行的过程中需要创建局部变量的时候就将局部变量的值存入栈帧的局部变量表中.
当着个方法执行吃那个完毕之后,这个方法所对应的栈帧建辉出栈,然后释放内存空间.
ps: 所谓的java栈和对 栈中放局部变量 堆中放对象 这种描述是有问题的. 
堆的理解尚可接受 但是栈是代表了java虚拟机栈中的局部变量表部分,真正的Java虚拟机栈是由一个个栈帧组成的.

### java虚拟机栈的特点

1. 局部变量表的创建实在方法被执行的时候,随着栈帧的创建而创建.而且局部变量表的大小在编译的时期就已经确定了,在创建的时候只要分配之前规定的大小就好.在方法运行的过程中,局部变量表是不会发生大小改变的
2. java虚拟机一般会有两种异常 StackOverflowError 和 OutOfMemoryError
1. 1.     StackOverflowError
  如果java虚拟机栈的内存大小不可以动态扩展,那么当线程请求栈的深度超过了java虚拟机栈的最大深度的时候就会抛出这个异常
1. 1.     OutOfMemoryError
  如果java虚拟机栈可以扩展,当线程请求的栈的内存用完了,无法继续扩展了,就会抛出这个异常
3. 这两个异常的区别
StackOverflowError表示当前线程申请的栈超过了之前设定好的最大深度,但是内存的空间还是可能有的.
OutOfMemoryError是当线程申请栈的时候栈已经满了,内存也没有了.

## 本地方法栈

### 什么是本地方法栈 
和java虚拟机栈的功能类似,本地方法栈是本地方法的运行内存模型.
本地方法被执行的时候也会创建一个栈帧,用于存放这个本地方法的局部变量表,操作数栈,动态链接和出口信息.
方法执行完毕之后会释放相应栈帧的内存空间,也会抛出StackOverflowError和OutOfMemoryError的异常.

## 堆
堆是用来存放对象的内存空间,**几乎所有**的对象都存在堆中

### 堆的特点
1. 线程共享  整个java虚拟机只有一个堆,所有的线程都访问一个相同的堆,而程序计数器和java虚拟机栈都是一个线程对应一个的.
2. 在虚拟机启动的时候就创建
3. 垃圾回收的主要场所
4. 可以进一步细分为新生代和老年代
新生代可以分为  Eden伊甸园    From Survior生还者   To Survior 
不同的区域存放具有不同生命周期的对象,根据不同的垃圾回收算法
5. 堆的大小既可以固定也可以扩展

==(重点链接到  Java 内存模型和 GC回收算法)==
## 方法区

### 什么是方法区

java虚拟机规范定义方法区是堆的一个逻辑部分.
方法区中存放着已经被虚拟机加载的类信息,常量,静态变量,及时编译器编译后的代码等等

### 方法区的特点

1. 线程共享 方法区是堆的一个逻辑部分和堆一样都是java虚拟机中所有线程共享的
2. 永久代 方法区中的信息需要长久存在而且同时是堆的逻辑分区,所以用堆的区分方法称为老年代.
3. 内存回收效率低 方法区中的信息一般要长久存在,回收之后一次只可能有少量的信息无效.对于方法区内存回收的主要目的就是:1]对常量池的回收 2]对类型的卸载.
4. java虚拟机对方法区的要求比较少,准许固定大小,也可以扩展还准许不垃圾回收.

### 什么是运行常量池

方法区中有三种数据: 类信息,常量和静态变量.即时编译之后的代码也放在常量池中.

通过 public static final 声明的常量,这个类被编译后生成的Class文件存储在这个class文件中.当这个类被虚拟机加载之后,class文件中的常量就放在方法区的运行时常量池中,而且在运行期间可以向常量池中添加常量. 如String 中的 intern 方法就能做到

## 直接内存

除了java虚拟机之外的内存,也有可能被java使用.

在NIO中引入了一种基于通道和缓冲的IO方式.可以通过调用本地方法直接分配java虚拟内存.[未研究]

# 总结

1. java 虚拟机额度内存模型有两个栈 是java虚拟机栈和本地方法栈[==区别==]
2. java 虚拟机中有两个堆,一个原本堆,一个是方法区.方法区的本质属于堆的一个逻辑部分,堆中存放对象,方法区中存放类信息,常量,静态变量,即时编译器编译的代码
3. 堆 是java虚拟机最大的一块内存区域,也是GC算法主要作用的区域.
4. 线程私有程序计数器,虚拟栈,本地方法栈.堆共享,之后jvm停止才会销毁.

